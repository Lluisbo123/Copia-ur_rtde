def rtde_control():
    global force_mode_type = 2
    global selection_vector = [0, 0, 0, 0, 0, 0]
    global task_frame = p[0, 0, 0, 0, 0, 0]
    global wrench = [0, 0, 0, 0, 0, 0]
    global limits = [0, 0, 0, 0, 0, 0]
    global is_servoing = 0
    global is_speeding = 0
    global is_in_forcemode = 0

    global servo_target = [0, 0, 0, 0, 0, 0]
    global servo_time = 0.002
    global servo_lookahead_time = 0.1
    global servo_gain = 300

    global servoc_target = p[0, 0, 0, 0, 0, 0]
    global servoc_acceleration = 1.2
    global servoc_velocity = 0.25
    global servoc_blend = 0

    global speed_type = 0
    global speed_target = [0, 0, 0, 0, 0, 0]
    global speed_acceleration = 0.5
    global speed_time = 0.5

    global move_thrd = 0
    global move_type = 0
    global move_p = p[0, 0, 0, 0, 0, 0]
    global move_q = [0, 0, 0, 0, 0, 0]
    global move_vel = 1.2
    global move_acc = 0.25

    global servo_thrd = 0
    global servoc_thrd = 0
    global speed_thrd = 0
    global force_thrd = 0

    global jog_feature = 0 # 0 - base, 1 - tool, 2 - custom
    global jog_speed_vector_dt = p[0, 0, 0, 0, 0, 0]
    global jog_start_pose = p[0, 0, 0, 0, 0, 0]
    global jog_thrd = 0
    global jog_dt = 0.002
    global jog_state = 0 # 0 - inactive, 1 - new setpoint, 2 - jogging, 3 - stopping (decelerating)

    def exec_movel_path():
      textmsg("exec_movel_path")
      # inject movel path
    end

    def exec_movej_path():
      textmsg("exec_movej_path")
      # inject movej path
    end


    thread move_thread():
        textmsg("move_thread started")
        while (True):
            if move_type == 0 or move_type == 1:
                movej(move_q, a=move_acc, v=move_vel)
            elif move_type == 2:
                movel(move_p, a=move_acc, v=move_vel)
            elif move_type == 3:
                movel(move_q, a=move_acc, v=move_vel)
            elif move_type == 4:
                exec_movel_path()
            elif move_type == 5:
                exec_movej_path()
            end
            enter_critical
            move_thrd = 0
            textmsg("move_thread finished")
            exit_critical
            break
        end
    end

    def stop_async_move():
        enter_critical
        if move_thrd != 0:
            textmsg("stopping async movement - killing move_thrd")
            kill move_thrd
            move_thrd = 0
        end
        exit_critical
    end

    thread force_thread():
        while (True):
            force_mode(task_frame, selection_vector, wrench, force_mode_type, limits)
            sync()
        end
    end

    thread speed_thread():
        while (True):
            enter_critical
            type = speed_type
            target = speed_target
            acceleration = speed_acceleration
            time = speed_time
            exit_critical
            if type == 0:
                if time > 0:
                    speedl(target, a=acceleration, t=time)
                else:
                    speedl(target, a=acceleration)
                end
            else:
                if time > 0:
                    speedj(target, a=acceleration, t=time)
                else:
                    speedj(target, a=acceleration)
                end
            end
        end
    end

    thread servo_thread():
        while (True):
            enter_critical
            q = servo_target
            dt = servo_time
            lh_time = servo_lookahead_time
            g = servo_gain
            exit_critical
            servoj(q, t=dt, lookahead_time=lh_time, gain=g)
        end
    end

    thread servoc_thread():
        while (True):
            servoc(servoc_target, a=servoc_acceleration, v=servoc_velocity, r=servoc_blend)
        end
    end

    def q_from_input_float_registers(register_index):
      q = [0, 0, 0, 0, 0, 0]
      q[0] = read_input_float_register(register_index + 0)
      q[1] = read_input_float_register(register_index + 1)
      q[2] = read_input_float_register(register_index + 2)
      q[3] = read_input_float_register(register_index + 3)
      q[4] = read_input_float_register(register_index + 4)
      q[5] = read_input_float_register(register_index + 5)
      return q
    end

    def pose_from_input_float_registers(register_index):
      pose = p[0, 0, 0, 0, 0, 0]
      pose[0] = read_input_float_register(register_index + 0)
      pose[1] = read_input_float_register(register_index + 1)
      pose[2] = read_input_float_register(register_index + 2)
      pose[3] = read_input_float_register(register_index + 3)
      pose[4] = read_input_float_register(register_index + 4)
      pose[5] = read_input_float_register(register_index + 5)
      return pose
    end

    def pose_to_output_float_registers(register_index, pose):
      write_output_float_register(register_index + 0, pose[0])
      write_output_float_register(register_index + 1, pose[1])
      write_output_float_register(register_index + 2, pose[2])
      write_output_float_register(register_index + 3, pose[3])
      write_output_float_register(register_index + 4, pose[4])
      write_output_float_register(register_index + 5, pose[5])
    end

    def q_to_output_float_registers(register_index, q):
      write_output_float_register(register_index + 0, q[0])
      write_output_float_register(register_index + 1, q[1])
      write_output_float_register(register_index + 2, q[2])
      write_output_float_register(register_index + 3, q[3])
      write_output_float_register(register_index + 4, q[4])
      write_output_float_register(register_index + 5, q[5])
    end

    # Returs a pose that contains only the translation part of a given pose
    def get_pose_translation(pose):
      return p[pose[0], pose[1], pose[2], 0, 0, 0]
    end
  
    # Returns a pose that contains only the rotation part of a given pose
    def get_pose_rotation(pose):
      return p[0, 0, 0, pose[3], pose[4], pose[5]]
    end

    # scales the given pose by the given factor
    def scale_pose(p, factor):
      p[0] = p[0] * factor
      p[1] = p[1] * factor
      p[2] = p[2] * factor
      p[3] = p[3] * factor
      p[4] = p[4] * factor
      p[5] = p[5] * factor
      return p
    end

  # The jog thread provides jogging functionality similar to the one you
  # find in the teach pendant.
  thread jog_thread():
    textmsg("jog_thread started")
    # We latch the global jog settings. The feature setting is only latched
    # here. That means, it is not possible to change the feature as soon as the 
    # move started. To change the feature, you first have to stop the move
    enter_critical
    start_pose = jog_start_pose
    feature = jog_feature
    exit_critical

    # Initialize target_pose depending on feature
    if feature == 0: # base feature
      target_pose = start_pose
    elif feature == 1: # tool feature
      target_pose = p[0, 0, 0, 0, 0, 0]
    end
    deceleration_counter = 0

    while (jog_state > 0 and deceleration_counter < 50):
      enter_critical
      if jog_state == 1: # 1 = new setpoint
        speeds = jog_speed_vector_dt
        jog_state = 2 # 2 = jogging
        deceleration_counter = 0
        textmsg("new jog setpoint")
      end
      exit_critical

      if jog_state == 3: # 3 - stopping (decelerating)
        # We do a simple deceleration by just decreasing the speed by a
        # certain factor. That is not a perfect deceleration ramp but it is
        # ok to prevent jerks when stopping the jog thread
        speeds = scale_pose(speeds, 0.7)
        deceleration_counter = deceleration_counter + 1
      else:
        deceleration_counter = 0
      end

      if feature == 0: # base feature
        target_transl = get_pose_translation(pose_add(target_pose, speeds))
        speeds_rot = get_pose_rotation(speeds)
        target_rot = pose_trans(speeds_rot, get_pose_rotation(target_pose))
        target_pose = pose_add(target_transl, target_rot)
        q = get_inverse_kin(target_pose)
      elif feature == 1: # tool feature
        target_pose = pose_add(target_pose, speeds)
        pose_wrt_base = pose_trans(start_pose, target_pose)
        q = get_inverse_kin(pose_wrt_base)
      end
      servoj(q, jog_dt, lookahead_time=0.03, gain=1000)
    end
    textmsg("jog_thread finished")
    enter_critical
    jogging_state = 0 # inactive
    jog_thrd = 0
    exit_critical
  end


    def signal_ready():
        write_output_integer_register(0, 1)
    end

    def signal_done_with_cmd():
        write_output_integer_register(0, 2)
    end

    def rtde_cmd():
        return read_input_integer_register(0)
    end

    def process_cmd():
        cmd = read_input_integer_register(0)

        if cmd == 1:
            textmsg("movej")
            q = q_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            async = read_input_integer_register(1)
            textmsg("Target q:")
            textmsg(q)
            stop_async_move()
            if async == 1:
                enter_critical
                move_type = 0
                move_q = q
                move_acc = acceleration
                move_vel = velocity
                exit_critical
                move_thrd = run move_thread()
            else:
                movej(q, a=acceleration, v=velocity)
                textmsg("movej done")
            end
        elif cmd == 2:
            textmsg("movej_ik")
            pose = pose_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            async = read_input_integer_register(1)
            textmsg("Target pose:")
            textmsg(pose)
            q = get_inverse_kin(pose)
            textmsg("Target q:")
            textmsg(q)
            stop_async_move()
            if async == 1:
                enter_critical
                move_type = 1
                move_q = q
                move_acc = acceleration
                move_vel = velocity
                exit_critical
                move_thrd = run move_thread()
            else:
                movej(q, a=acceleration, v=velocity)
                textmsg("movej_ik done")
            end
        elif cmd == 3:
            textmsg("movel")
            pose = pose_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            async = read_input_integer_register(1)
            textmsg("Target pose:")
            textmsg(pose)
            stop_async_move()
            if async == 1:
                enter_critical
                move_type = 2
                move_p = pose
                move_acc = acceleration
                move_vel = velocity
                exit_critical
                move_thrd = run move_thread()
            else:
                movel(pose, a=acceleration, v=velocity)
                textmsg("movel done")
            end
        elif cmd == 4:
            textmsg("movel_fk")
            q = q_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            async = read_input_integer_register(1)
            textmsg("Target q:")
            textmsg(q)
            stop_async_move()
            if async == 1:
                enter_critical
                move_type = 3
                move_q = q
                move_acc = acceleration
                move_vel = velocity
                exit_critical
                move_thrd = run move_thread()
            else:
                movel(q, a=acceleration, v=velocity)
                textmsg("movel_fk done")
            end
        elif cmd == 5:
            textmsg("movec")
            pose_via = pose_from_input_float_registers(0)
            pose_to = pose_from_input_float_registers(6)
            velocity = read_input_float_register(12)
            acceleration = read_input_float_register(13)
            blend = read_input_float_register(14)
            movec_mode = read_input_integer_register(1)
            textmsg("pose_via:")
            textmsg(pose_via)
            textmsg("pose_to:")
            textmsg(pose_to)
            movec(pose_via, pose_to, a=acceleration, v=velocity, r=blend, mode=movec_mode)
            textmsg("movec done")
        elif cmd == 6:
            # force_mode
            enter_critical
            force_mode_type = read_input_integer_register(1)
            selection_vector[0] = read_input_integer_register(2)
            selection_vector[1] = read_input_integer_register(3)
            selection_vector[2] = read_input_integer_register(4)
            selection_vector[3] = read_input_integer_register(5)
            selection_vector[4] = read_input_integer_register(6)
            selection_vector[5] = read_input_integer_register(7)

            task_frame = pose_from_input_float_registers(0)
            wrench = q_from_input_float_registers(6)
            limits = q_from_input_float_registers(12)
            exit_critical

            if is_in_forcemode == 0:
                is_in_forcemode = 1
                if force_thrd == 0:
                    global force_thrd = run force_thread()
                end
            end
        elif cmd == 7:
            textmsg("force_mode_stop")
            enter_critical
            is_in_forcemode = 0
            kill force_thrd
            force_thrd = 0
            end_force_mode()
            stopl(10)
            exit_critical
            textmsg("force_mode stopped")
        elif cmd == 8:
            textmsg("zero_ftsensor")
            zero_ftsensor()
            textmsg("ftsensor zeroed")
        elif cmd == 9:
            # speedJ
            qd = q_from_input_float_registers(0)

            enter_critical
            speed_type = 1
            speed_acceleration = read_input_float_register(6)
            speed_time = read_input_float_register(7)
            speed_target = qd
            exit_critical

            if is_speeding == 0:
                enter_critical
                is_speeding = 1
                exit_critical
                if speed_thrd == 0:
                    global speed_thrd = run speed_thread()
                end
            end
        elif cmd == 10:
            # speedL
            xd = q_from_input_float_registers(0)
            enter_critical
            speed_type = 0
            speed_acceleration = read_input_float_register(6)
            speed_time = read_input_float_register(7)
            speed_target = xd
            exit_critical

            if is_speeding == 0:
                is_speeding = 1
                if speed_thrd == 0:
                    global speed_thrd = run speed_thread()
                end
            end
        elif cmd == 11:
            # servoJ
            q = q_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)

            enter_critical
            servo_target = q
            servo_time = read_input_float_register(8)
            servo_lookahead_time = read_input_float_register(9)
            servo_gain = read_input_float_register(10)
            exit_critical

            if is_servoing == 0:
                is_servoing = 1
                if servo_thrd == 0:
                    global servo_thrd = run servo_thread()
                end
            end
            
        elif cmd == 12:
            # servoC
            pose = pose_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            blend = read_input_float_register(8)

            enter_critical
            servoc_target = pose
            servoc_acceleration = acceleration
            servoc_velocity = velocity
            servoc_blend = blend
            exit_critical

            if is_servoing == 0:
                is_servoing = 1
                if servoc_thrd == 0:
                    global servo_thrd = run servoc_thread()
                end
            end

        elif cmd == 15:
            textmsg("speed_stop")
            enter_critical
            is_speeding = 0
            kill speed_thrd
            speed_thrd = 0
            if speed_type == 0:
                stopl(10)
            else:
                stopj(10)
            end
            exit_critical
            textmsg("speed_stop done")
        elif cmd == 16:
            textmsg("servo_stop")
            enter_critical
            is_servoing = 0
            kill servo_thrd
            kill servoc_thrd
            servo_thrd = 0
            servoc_thrd = 0
            exit_critical
            stopl(20)
            textmsg("servo_stop done")
        elif cmd == 17:
            textmsg("set_payload")
            mass = read_input_float_register(0)
            cog_x = read_input_float_register(1)
            cog_y = read_input_float_register(2)
            cog_z = read_input_float_register(3)
            cog = [cog_x, cog_y, cog_z]
$V50        if cog_x == 0 and cog_y == 0 and cog_z == 0:
$V50            set_payload(mass, get_target_payload_cog())
$V50        else:
                set_payload(mass, cog)
$V50        end
$V50        textmsg("active payload:")
$V50        textmsg(get_target_payload())
            textmsg("set_payload done")
        elif cmd == 18:
            textmsg("teach_mode")
            teach_mode()
            textmsg("teach_mode done")
        elif cmd == 19:
            textmsg("end_teach_mode")
            end_teach_mode()
            textmsg("end_teach_mode done")
        elif cmd == 20:
            textmsg("force_mode_set_damping")
            damping = read_input_float_register(0)
$V35        force_mode_set_damping(damping)
            textmsg("force_mode_set_damping done")
        elif cmd == 21:
            textmsg("force_mode_set_gain_scaling")
            scaling = read_input_float_register(0)
$V50        force_mode_set_gain_scaling(scaling)
            textmsg("force_mode_set_gain_scaling done")
        elif cmd == 24:
            pose = pose_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            q = get_inverse_kin(pose)

            enter_critical
            servo_target = q
            servo_time = read_input_float_register(8)
            servo_lookahead_time = read_input_float_register(9)
            servo_gain = read_input_float_register(10)
            exit_critical

            if is_servoing == 0:
                is_servoing = 1
                if servo_thrd == 0:
                    global servo_thrd = run servo_thread()
                end
            end
        elif cmd == 25:
            textmsg("tool_contact")
            direction = pose_from_input_float_registers(0)
$V54        time_steps = tool_contact(direction)
$V54        write_output_integer_register(1, time_steps)
$V54        textmsg("tool_contact timesteps:")
$V54        textmsg(time_steps)
            textmsg("tool_contact done")
        elif cmd == 26:
            textmsg("get_steptime")
$V54        step_time = get_steptime()
$V54        write_output_float_register(0, step_time)
$V54        textmsg("get_steptime step_time:")
$V54        textmsg(step_time)
            textmsg("get_steptime done")
        elif cmd == 27:
            textmsg("get_actual_joint_positions_history")
            steps = read_input_integer_register(1)
$V54        textmsg(steps)
$V54        joint_positions_history = get_actual_joint_positions_history(steps)
$V54        textmsg(joint_positions_history)
$V54        q_to_output_float_registers(0, joint_positions_history)
            textmsg("get_actual_joint_positions_history done")
        elif cmd == 28:
            textmsg("get_target_waypoint")
$V53        target_waypoint = get_target_waypoint()
$V53        pose_to_output_float_registers(0, target_waypoint)
            textmsg("get_target_waypoint done")
        elif cmd == 29:
            textmsg("set_tcp")
            pose = pose_from_input_float_registers(0)
            set_tcp(pose)
            textmsg("set_tcp done")
        elif cmd == 30:
            textmsg("get_inverse_kin_args")
            x = pose_from_input_float_registers(0)
            qnear = q_from_input_float_registers(6)
            maxPositionError = read_input_float_register(12)
            maxOrientationError = read_input_float_register(13)

            q = get_inverse_kin(x, qnear, maxPositionError, maxOrientationError)
            q_to_output_float_registers(0, q)
            textmsg("get_inverse_kin done")
        elif cmd == 31:
            textmsg("protective_stop")
$V38        protective_stop()
            textmsg("protective_stop done")
        elif cmd == 32:
            textmsg("movep")
            pose = pose_from_input_float_registers(0)
            velocity = read_input_float_register(6)
            acceleration = read_input_float_register(7)
            blend = read_input_float_register(8)
            movep(pose, a=acceleration, v=velocity, r=blend)
            textmsg("movep done")
        elif cmd == 33:
            textmsg("stopl")
            deceleration_rate = read_input_float_register(0)
            stop_async_move()
            stopl(deceleration_rate)
            textmsg("stopl done")
        elif cmd == 34:
            textmsg("stopj")
            deceleration_rate = read_input_float_register(0)
            stop_async_move()
            stopj(deceleration_rate)
            textmsg("stopj done")
        elif cmd == 35:
            textmsg("set_watchdog")
            # Setup watchdog for the RTDE communication
            watchdog_min_frequency = read_input_float_register(0)
            rtde_set_watchdog("input_int_register_0", watchdog_min_frequency, "stop")
            textmsg("set_watchdog done")
        elif cmd == 36:
            textmsg("is_pose_within_safety_limits")
            pose = pose_from_input_float_registers(0)
            safe_pose = is_within_safety_limits(pose)
            if safe_pose == True:
               write_output_integer_register(1, 1)
            else:
               write_output_integer_register(1, 0)
            end
            textmsg("is_pose_within_safety_limits done")
        elif cmd == 37:
            textmsg("is_joints_within_safety_limits")
            q = q_from_input_float_registers(0)
            safe_q = is_within_safety_limits(q)
            if safe_q == True:
               write_output_integer_register(1, 1)
            else:
               write_output_integer_register(1, 0)
            end
            textmsg("is_joints_within_safety_limits done")
        elif cmd == 38:
            textmsg("get_joint_torques")
            torques = get_joint_torques()
            q_to_output_float_registers(0, torques)
            textmsg("get_joint_torques done")
        elif cmd == 39:
            textmsg("pose_trans")
            p_from = pose_from_input_float_registers(0)
            p_from_to = pose_from_input_float_registers(6)
            p = pose_trans(p_from, p_from_to)
            pose_to_output_float_registers(0, p)
            textmsg("pose_trans done")
        elif cmd == 40:
            textmsg("get_tcp_offset")
$V36        tcp_offset = get_tcp_offset()
$V36        textmsg(tcp_offset)
$V36        pose_to_output_float_registers(0, tcp_offset)
            textmsg("get_tcp_offset done")
        elif cmd == 41:
              textmsg("start_jog")
              enter_critical
              jog_state = 1 # 3 = stopping (decelerating)
              speed_pose = pose_from_input_float_registers(0)
              jog_speed_vector_dt = scale_pose(speed_pose, jog_dt)
              jog_feature = read_input_float_register(6)
              jog_start_pose = get_actual_tcp_pose()
              if jog_thrd == 0:
                jog_thrd = run jog_thread()
              end
              exit_critical
              textmsg("jog_speed_vector_dt: ", jog_speed_vector_dt)
              textmsg("jog_feature: ", jog_feature)
              textmsg("start_jog done")    
        elif cmd == 42:
              textmsg("stop_jog")
              jog_state = 3 # 3 = stopping (decelerating)
              join jog_thrd
              textmsg("stop_jog done")
        elif cmd == 43:
              textmsg("get_forward_kinematics_default")
              forward_kin = get_forward_kin()
              textmsg(forward_kin)
              pose_to_output_float_registers(0, forward_kin)
              textmsg("get_forward_kinematics_default done")
        elif cmd == 44:
              textmsg("get_forward_kinematics_args")
              q = q_from_input_float_registers(0)
              tcp_offset = pose_from_input_float_registers(6)
              forward_kin = get_forward_kin(q, tcp_offset)
              textmsg(forward_kin)
              pose_to_output_float_registers(0, forward_kin)
              textmsg("get_forward_kinematics_args done")
        elif cmd == 45:
              textmsg("movel_path")
              async = read_input_integer_register(1)
              textmsg("async: ", async)
              stop_async_move()
              if async == 1:
                  enter_critical
                  move_type = 4 # movel_path
                  exit_critical
                  move_thrd = run move_thread()
              else:
                  exec_movel_path()
                  textmsg("movel_path done")
              end
        elif cmd == 46:
              textmsg("movej_path")
              async = read_input_integer_register(1)
              textmsg("async: ", async)
              stop_async_move()
              if async == 1:
                  enter_critical
                  move_type = 5 # movej_path
                  exit_critical
                  move_thrd = run move_thread()
              else:
                  exec_movej_path()
                  textmsg("movej_path done")
              end
        elif cmd == 47:
              textmsg("get_inverse_kin_default")
              x = pose_from_input_float_registers(0)
              q = get_inverse_kin(x)
              q_to_output_float_registers(0, q)
              textmsg("get_inverse_kin_default done")
        elif cmd == 48:
              textmsg("is_steady")
              robot_is_steady = is_steady()
              if robot_is_steady == True:
                 write_output_integer_register(1, 1)
              else:
                 write_output_integer_register(1, 0)
              end
              textmsg("is_steady done")

        elif cmd == 255:
            textmsg("Received stop script!")
        end

        if cmd != 255:
            signal_done_with_cmd()
        end

        return cmd != 255
    end

    #
    # RTDE Control script - Main loop
    #

    textmsg("RTDE Control Script Loaded (25.11.2020-13:32)")

    # Initialize gain and damping for force mode to a more stable default
$V50force_mode_set_gain_scaling(0.5)
$V35force_mode_set_damping(0.025)

    keep_running = True
    executing_cmd = False
    signal_ready()

    while keep_running:
        cmd = rtde_cmd()
        if cmd == 24 or cmd == 11 or cmd == 9 or cmd == 10 or cmd == 6:
            # servo or speed or force mode, simply process and signal ready.
            keep_running = process_cmd()
            signal_ready()
        else:
            # regular mode
            if cmd == 0:
                executing_cmd = False
                signal_ready()
            else:
                if not executing_cmd:
                    keep_running = process_cmd()
                end
                executing_cmd = True
            end
        end
        
        sync()
    end
    textmsg("RTDE Control Script Terminated")
end
run program
